// THIS IS AN AUTOMATICALLY GENERATED CODE! DO NOT EDIT THIS FILE!
// ADD YOUR EVENT TO 'generate_event_dispatcher.go' AND RUN 'go generate'

package events

import (
	"time"
)

// #######################
// INTERFACE DOCUMENTATION
// #######################

// 1. Create EventDispatcher using NewEventDispatcher() function.
// 2. Register your listeners using EventDispatcher.Register<event type name>Listener methods.
// 3. Run event loop by calling EventDispatcher.RunEventLoop() method.
// 4. Trigger events using EventDispatcher.Fire<event type name> methods.

// LISTENER INTERFACES

type TimeTickListener interface {
	HandleTimeTick(*TimeTick)
}

type CommunicationTimeTickListener interface {
	HandleCommunicationTimeTick(*CommunicationTimeTick)
}

type ProjectileFiredListener interface {
	HandleProjectileFired(*ProjectileFired)
}

type ProjectileHitListener interface {
	HandleProjectileHit(*ProjectileHit)
}

type UserJoinedListener interface {
	HandleUserJoined(*UserJoined)
}

type UserLeftListener interface {
	HandleUserLeft(*UserLeft)
}

type UserDiedListener interface {
	HandleUserDied(*UserDied)
}

type UserInputListener interface {
	HandleUserInput(*UserInput)
}

type TargetAngleListener interface {
	HandleTargetAngle(*TargetAngle)
}

// ##############################
// END OF INTERFACE DOCUMENTATION
// ##############################

const (
	eventQueuesCapacity                                       = 100000
	idleDispatcherSleepTime                     time.Duration = 5 * time.Millisecond
	registeringListenerWhileRunningErrorMessage               = "Tried to register listener while running event loop. Registering listeners is not thread safe therefore prohibited after starting event loop."
)

// PRIVATE EVENT HANDLERS

type eventHandler interface {
	handle()
}

type timeTickHandler struct {
	event          *TimeTick
	eventListeners []TimeTickListener
}

func (handler *timeTickHandler) handle() {
	for _, listener := range handler.eventListeners {
		listener.HandleTimeTick(handler.event)
	}
}

type communicationTimeTickHandler struct {
	event          *CommunicationTimeTick
	eventListeners []CommunicationTimeTickListener
}

func (handler *communicationTimeTickHandler) handle() {
	for _, listener := range handler.eventListeners {
		listener.HandleCommunicationTimeTick(handler.event)
	}
}

type projectileFiredHandler struct {
	event          *ProjectileFired
	eventListeners []ProjectileFiredListener
}

func (handler *projectileFiredHandler) handle() {
	for _, listener := range handler.eventListeners {
		listener.HandleProjectileFired(handler.event)
	}
}

type projectileHitHandler struct {
	event          *ProjectileHit
	eventListeners []ProjectileHitListener
}

func (handler *projectileHitHandler) handle() {
	for _, listener := range handler.eventListeners {
		listener.HandleProjectileHit(handler.event)
	}
}

type userJoinedHandler struct {
	event          *UserJoined
	eventListeners []UserJoinedListener
}

func (handler *userJoinedHandler) handle() {
	for _, listener := range handler.eventListeners {
		listener.HandleUserJoined(handler.event)
	}
}

type userLeftHandler struct {
	event          *UserLeft
	eventListeners []UserLeftListener
}

func (handler *userLeftHandler) handle() {
	for _, listener := range handler.eventListeners {
		listener.HandleUserLeft(handler.event)
	}
}

type userDiedHandler struct {
	event          *UserDied
	eventListeners []UserDiedListener
}

func (handler *userDiedHandler) handle() {
	for _, listener := range handler.eventListeners {
		listener.HandleUserDied(handler.event)
	}
}

type userInputHandler struct {
	event          *UserInput
	eventListeners []UserInputListener
}

func (handler *userInputHandler) handle() {
	for _, listener := range handler.eventListeners {
		listener.HandleUserInput(handler.event)
	}
}

type targetAngleHandler struct {
	event          *TargetAngle
	eventListeners []TargetAngleListener
}

func (handler *targetAngleHandler) handle() {
	for _, listener := range handler.eventListeners {
		listener.HandleTargetAngle(handler.event)
	}
}

// EVENT DISPATCHER

type EventDispatcher struct {
	running bool

	// EVENT QUEUES

	priority1EventsQueue chan eventHandler

	priority2EventsQueue chan eventHandler

	priority3EventsQueue chan eventHandler

	// LISTENER LISTS

	timeTickListeners []TimeTickListener

	communicationTimeTickListeners []CommunicationTimeTickListener

	projectileFiredListeners []ProjectileFiredListener

	projectileHitListeners []ProjectileHitListener

	userJoinedListeners []UserJoinedListener

	userLeftListeners []UserLeftListener

	userDiedListeners []UserDiedListener

	userInputListeners []UserInputListener

	targetAngleListeners []TargetAngleListener
}

// EVENT DISPATCHER CONSTRUCTOR

func NewEventDispatcher() *EventDispatcher {
	return &EventDispatcher{
		running: false,

		// EVENT QUEUES

		priority1EventsQueue: make(chan eventHandler, eventQueuesCapacity),

		priority2EventsQueue: make(chan eventHandler, eventQueuesCapacity),

		priority3EventsQueue: make(chan eventHandler, eventQueuesCapacity),

		// LISTENER LISTS

		timeTickListeners: []TimeTickListener{},

		communicationTimeTickListeners: []CommunicationTimeTickListener{},

		projectileFiredListeners: []ProjectileFiredListener{},

		projectileHitListeners: []ProjectileHitListener{},

		userJoinedListeners: []UserJoinedListener{},

		userLeftListeners: []UserLeftListener{},

		userDiedListeners: []UserDiedListener{},

		userInputListeners: []UserInputListener{},

		targetAngleListeners: []TargetAngleListener{},
	}
}

// MAIN EVENT LOOP

func (dispatcher *EventDispatcher) RunEventLoop() {
	dispatcher.running = true

	for {
		select {

		case handler := <-dispatcher.priority1EventsQueue:
			handler.handle()

		case handler := <-dispatcher.priority2EventsQueue:
			handler.handle()

		case handler := <-dispatcher.priority3EventsQueue:
			handler.handle()

		default:
			time.Sleep(idleDispatcherSleepTime)
		}
	}
}

func (dispatcher *EventDispatcher) panicWhenEventLoopRunning() {
	if dispatcher.running {
		panic(registeringListenerWhileRunningErrorMessage)
	}
}

// PUBLIC EVENT DISPATCHER METHODS

// TimeTick

func (dispatcher *EventDispatcher) RegisterTimeTickListener(listener TimeTickListener) {
	dispatcher.panicWhenEventLoopRunning()

	dispatcher.timeTickListeners = append(dispatcher.timeTickListeners, listener)
}

func (dispatcher *EventDispatcher) FireTimeTick(event *TimeTick) {
	handler := &timeTickHandler{
		event:          event,
		eventListeners: dispatcher.timeTickListeners,
	}

	dispatcher.priority1EventsQueue <- handler
}

// CommunicationTimeTick

func (dispatcher *EventDispatcher) RegisterCommunicationTimeTickListener(listener CommunicationTimeTickListener) {
	dispatcher.panicWhenEventLoopRunning()

	dispatcher.communicationTimeTickListeners = append(dispatcher.communicationTimeTickListeners, listener)
}

func (dispatcher *EventDispatcher) FireCommunicationTimeTick(event *CommunicationTimeTick) {
	handler := &communicationTimeTickHandler{
		event:          event,
		eventListeners: dispatcher.communicationTimeTickListeners,
	}

	dispatcher.priority1EventsQueue <- handler
}

// ProjectileFired

func (dispatcher *EventDispatcher) RegisterProjectileFiredListener(listener ProjectileFiredListener) {
	dispatcher.panicWhenEventLoopRunning()

	dispatcher.projectileFiredListeners = append(dispatcher.projectileFiredListeners, listener)
}

func (dispatcher *EventDispatcher) FireProjectileFired(event *ProjectileFired) {
	handler := &projectileFiredHandler{
		event:          event,
		eventListeners: dispatcher.projectileFiredListeners,
	}

	dispatcher.priority2EventsQueue <- handler
}

// ProjectileHit

func (dispatcher *EventDispatcher) RegisterProjectileHitListener(listener ProjectileHitListener) {
	dispatcher.panicWhenEventLoopRunning()

	dispatcher.projectileHitListeners = append(dispatcher.projectileHitListeners, listener)
}

func (dispatcher *EventDispatcher) FireProjectileHit(event *ProjectileHit) {
	handler := &projectileHitHandler{
		event:          event,
		eventListeners: dispatcher.projectileHitListeners,
	}

	dispatcher.priority2EventsQueue <- handler
}

// UserJoined

func (dispatcher *EventDispatcher) RegisterUserJoinedListener(listener UserJoinedListener) {
	dispatcher.panicWhenEventLoopRunning()

	dispatcher.userJoinedListeners = append(dispatcher.userJoinedListeners, listener)
}

func (dispatcher *EventDispatcher) FireUserJoined(event *UserJoined) {
	handler := &userJoinedHandler{
		event:          event,
		eventListeners: dispatcher.userJoinedListeners,
	}

	dispatcher.priority2EventsQueue <- handler
}

// UserLeft

func (dispatcher *EventDispatcher) RegisterUserLeftListener(listener UserLeftListener) {
	dispatcher.panicWhenEventLoopRunning()

	dispatcher.userLeftListeners = append(dispatcher.userLeftListeners, listener)
}

func (dispatcher *EventDispatcher) FireUserLeft(event *UserLeft) {
	handler := &userLeftHandler{
		event:          event,
		eventListeners: dispatcher.userLeftListeners,
	}

	dispatcher.priority2EventsQueue <- handler
}

// UserDied

func (dispatcher *EventDispatcher) RegisterUserDiedListener(listener UserDiedListener) {
	dispatcher.panicWhenEventLoopRunning()

	dispatcher.userDiedListeners = append(dispatcher.userDiedListeners, listener)
}

func (dispatcher *EventDispatcher) FireUserDied(event *UserDied) {
	handler := &userDiedHandler{
		event:          event,
		eventListeners: dispatcher.userDiedListeners,
	}

	dispatcher.priority2EventsQueue <- handler
}

// UserInput

func (dispatcher *EventDispatcher) RegisterUserInputListener(listener UserInputListener) {
	dispatcher.panicWhenEventLoopRunning()

	dispatcher.userInputListeners = append(dispatcher.userInputListeners, listener)
}

func (dispatcher *EventDispatcher) FireUserInput(event *UserInput) {
	handler := &userInputHandler{
		event:          event,
		eventListeners: dispatcher.userInputListeners,
	}

	dispatcher.priority3EventsQueue <- handler
}

// TargetAngle

func (dispatcher *EventDispatcher) RegisterTargetAngleListener(listener TargetAngleListener) {
	dispatcher.panicWhenEventLoopRunning()

	dispatcher.targetAngleListeners = append(dispatcher.targetAngleListeners, listener)
}

func (dispatcher *EventDispatcher) FireTargetAngle(event *TargetAngle) {
	handler := &targetAngleHandler{
		event:          event,
		eventListeners: dispatcher.targetAngleListeners,
	}

	dispatcher.priority3EventsQueue <- handler
}
