package events

// GENERATED CODE! DO NOT EDIT THIS FILE!
// ADD YOUR EVENT AND RUN 'go generate' INSTEAD

import (
	"time"
)

const (
	buffersLength                         = 10000
	idleDispatcherSleepTime time.Duration = 5 * time.Millisecond
)

type TimeTickListener interface {
	HandleTimeTick(*TimeTick)
}

type ProjectileFiredListener interface {
	HandleProjectileFired(*ProjectileFired)
}

type UserInputListener interface {
	HandleUserInput(*UserInput)
}

type EventDispatcher interface {
	RunEventLoop()

	// TimeTick

	RegisterTimeTickListener(listener TimeTickListener)
	FireTimeTick(e *TimeTick)

	// ProjectileFired

	RegisterProjectileFiredListener(listener ProjectileFiredListener)
	FireProjectileFired(e *ProjectileFired)

	// UserInput

	RegisterUserInputListener(listener UserInputListener)
	FireUserInput(e *UserInput)
}

type EventDispatcherImpl struct {

	// TimeTick
	timeTickQueue     chan *TimeTick
	timeTickListeners []TimeTickListener

	// ProjectileFired
	projectileFiredQueue     chan *ProjectileFired
	projectileFiredListeners []ProjectileFiredListener

	// UserInput
	userInputQueue     chan *UserInput
	userInputListeners []UserInputListener
}

func NewEventDispatcher() EventDispatcher {
	return &EventDispatcherImpl{

		// TimeTick
		timeTickQueue:     make(chan *TimeTick, buffersLength),
		timeTickListeners: []TimeTickListener{},

		// ProjectileFired
		projectileFiredQueue:     make(chan *ProjectileFired, buffersLength),
		projectileFiredListeners: []ProjectileFiredListener{},

		// UserInput
		userInputQueue:     make(chan *UserInput, buffersLength),
		userInputListeners: []UserInputListener{},
	}
}

func (d *EventDispatcherImpl) RunEventLoop() {
	for {
		select {

		// TimeTick
		case event := <-d.timeTickQueue:
			for _, listener := range d.timeTickListeners {
				listener.HandleTimeTick(event)
			}

		// ProjectileFired
		case event := <-d.projectileFiredQueue:
			for _, listener := range d.projectileFiredListeners {
				listener.HandleProjectileFired(event)
			}

		// UserInput
		case event := <-d.userInputQueue:
			for _, listener := range d.userInputListeners {
				listener.HandleUserInput(event)
			}

		default:
			time.Sleep(idleDispatcherSleepTime)
		}
	}
}

// EVENT METHODS

// TimeTick

func (d *EventDispatcherImpl) RegisterTimeTickListener(listener TimeTickListener) {
	d.timeTickListeners = append(d.timeTickListeners, listener)
}

func (d *EventDispatcherImpl) FireTimeTick(e *TimeTick) {
	d.timeTickQueue <- e
}

// ProjectileFired

func (d *EventDispatcherImpl) RegisterProjectileFiredListener(listener ProjectileFiredListener) {
	d.projectileFiredListeners = append(d.projectileFiredListeners, listener)
}

func (d *EventDispatcherImpl) FireProjectileFired(e *ProjectileFired) {
	d.projectileFiredQueue <- e
}

// UserInput

func (d *EventDispatcherImpl) RegisterUserInputListener(listener UserInputListener) {
	d.userInputListeners = append(d.userInputListeners, listener)
}

func (d *EventDispatcherImpl) FireUserInput(e *UserInput) {
	d.userInputQueue <- e
}
