package main

import (
	"text/template"
	"go/format"
	"unicode"
	"bytes"
	"io/ioutil"
)

func pascalCaseToCamel(str string) string {
	out := []rune(str)
	out[0] = unicode.ToLower(out[0])
	return string(out)
}

type EventType struct {
	eventTypeName string
}

func (et *EventType) TypeName() string {
	return et.eventTypeName
}

func (et *EventType) ListenerTypeName() string {
	return et.eventTypeName + "Listener"
}

func (et *EventType) EventsQueueName() string {
	return pascalCaseToCamel(et.eventTypeName + "Queue")
}

func (et *EventType) ListenerListName() string {
	return pascalCaseToCamel(et.eventTypeName + "Listeners")
}

func (et *EventType) ListenerHandleMethodName() string {
	return "Handle" + et.eventTypeName
}

func (et *EventType) RegisterMethodName() string {
	return "Register" + et.eventTypeName + "Listener"
}

func (et *EventType) FireMethodName() string {
	return "Fire" + et.eventTypeName
}

type Metadata struct {
	TypeName               string
	ImplementationTypeName string
	EventLoopMethodName    string
	EventTypes             []EventType
}

func checkError(err error) {
	if err != nil {
		panic(err)
	}
}

func main() {
	codeTemplate := `
		package events

		// GENERATED CODE! DO NOT EDIT THIS FILE!
		// ADD YOUR EVENT AND RUN 'go generate' INSTEAD

		import (
			"time"
		)

		const (
			buffersLength = 10000
			idleDispatcherSleepTime time.Duration = 5 * time.Millisecond
		)

		{{ range .EventTypes }}
			type {{ .ListenerTypeName }} interface {
				{{ .ListenerHandleMethodName }}(*{{ .TypeName }})
			}
		{{ end }}

		type {{ .TypeName }} interface {
			{{ .EventLoopMethodName }}()
			{{ range .EventTypes }}
				// {{ .TypeName }}

				{{ .RegisterMethodName }}(listener {{ .ListenerTypeName }})
				{{ .FireMethodName }}(e *{{ .TypeName }})
			{{ end }}
		}

		type {{ .ImplementationTypeName }} struct {
			{{ range .EventTypes }}
				// {{ .TypeName }}
				{{ .EventsQueueName }} chan *{{ .TypeName }}
				{{ .ListenerListName }} []{{ .ListenerTypeName }}
			{{ end }}
		}

		func New{{ .TypeName }}() {{ .TypeName }} {
			return &{{ .ImplementationTypeName }}{
				{{ range .EventTypes }}
					// {{ .TypeName }}
					{{ .EventsQueueName }}: make(chan *{{ .TypeName }}, buffersLength),
					{{ .ListenerListName }}: []{{ .ListenerTypeName }}{},
				{{ end }}
			}
		}

		func (d *{{ .ImplementationTypeName }}) {{ .EventLoopMethodName }}() {
			for {
				select {
					{{ range .EventTypes }}
						// {{ .TypeName }}
						case event := <-d.{{ .EventsQueueName }}:
							for _, listener := range d.{{ .ListenerListName }} {
								listener.{{ .ListenerHandleMethodName }}(event)
							}
					{{ end }}
				default:
					time.Sleep(idleDispatcherSleepTime)
				}
			}
		}

		// EVENT METHODS

		{{ range .EventTypes }}
			// {{ .TypeName }}

			func (d *{{ $.ImplementationTypeName }}) {{ .RegisterMethodName }}(listener {{ .ListenerTypeName }}) {
				d.{{ .ListenerListName }} = append(d.{{ .ListenerListName }}, listener)
			}

			func (d *{{ $.ImplementationTypeName }}) {{ .FireMethodName }}(e *{{ .TypeName }}) {
				d.{{ .EventsQueueName }} <- e
			}
		{{ end }}
	`

	tpl, err := template.New("event_dispatcher").Parse(codeTemplate)
	checkError(err)

	var buffer bytes.Buffer
	err = tpl.Execute(&buffer, Metadata{
		TypeName: "EventDispatcher",
		ImplementationTypeName: "EventDispatcherImpl",
		EventLoopMethodName: "RunEventLoop",

		// TODO: load this list automatically
		EventTypes: []EventType{
			{"TimeTick"},
			{"ProjectileFired"},
			{"UserInput"},
		},
	})
	checkError(err)

	formatted_code, err := format.Source(buffer.Bytes())

	err = ioutil.WriteFile("backend/events/event_dispatcher.go", formatted_code, 0644)
	checkError(err)
}
