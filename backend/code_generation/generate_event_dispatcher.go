package main

import (
	"text/template"
	"go/format"
	"unicode"
	"bytes"
	"io/ioutil"
	"strconv"
	"sort"
)

// BEGIN CONFIGURATION

const (
	targetTypeName = "EventDispatcher"
	targetFilePath = "backend/events/event_dispatcher.go"
	eventLoopMethodName = "RunEventLoop"
	initialPriorityQueueCapacity = 100000
)

var supportedEvents = []EventType{
	{eventTypeName: "TimeTick", priority: 1},
	{eventTypeName: "CommunicationTimeTick", priority: 1},
	{eventTypeName: "ProjectileFired", priority: 2},
	{eventTypeName: "ProjectileHit", priority: 2},
	{eventTypeName: "UserJoined", priority: 2},
	{eventTypeName: "UserLeft", priority: 2},
	{eventTypeName: "UserDied", priority: 2},
	{eventTypeName: "UserInput", priority: 3},
	{eventTypeName: "TargetAngle", priority: 3},
}

// END CONFIGURATION

func pascalCaseToCamel(str string) string {
	out := []rune(str)
	out[0] = unicode.ToLower(out[0])
	return string(out)
}

type EventType struct {
	eventTypeName string
	priority      uint
}

func (et *EventType) TypeName() string {
	return et.eventTypeName
}

func (et *EventType) ListenerTypeName() string {
	return et.eventTypeName + "Listener"
}

func (et *EventType) HandlerTypeName() string {
	return pascalCaseToCamel(et.eventTypeName + "Handler")
}

func EventsQueueName(priority int) string {
	return "priority" + strconv.Itoa(int(priority)) + "EventsQueue"
}

func (et *EventType) EventsQueueName() string {
	return EventsQueueName(int(et.priority))
}

func (et *EventType) ListenerListName() string {
	return pascalCaseToCamel(et.eventTypeName + "Listeners")
}

func (et *EventType) ListenerHandleMethodName() string {
	return "Handle" + et.eventTypeName
}

func (et *EventType) RegisterMethodName() string {
	return "Register" + et.eventTypeName + "Listener"
}

func (et *EventType) FireMethodName() string {
	return "Fire" + et.eventTypeName
}

type Metadata struct {
	TypeName                     string
	EventLoopMethodName          string
	InitialPriorityQueueCapacity uint
	EventHandlerInterfaceName    string
	EventTypes                   []EventType
}

func (et Metadata) OrderedPriorityQueueNames() []string {
	priorities := make(map[uint]bool);

	for _, eventType := range et.EventTypes {
		priorities[eventType.priority] = true
	}

	sortedPriorities := make([]int, len(priorities))
	i := 0
	for priority := range priorities {
		sortedPriorities[i] = int(priority)
		i++
	}
	sort.Ints(sortedPriorities)

	sortedQueueNames := make([]string, len(priorities))
	for i, priority := range sortedPriorities {
		sortedQueueNames[i] = EventsQueueName(priority)
	}

	return sortedQueueNames
}

func checkError(err error) {
	if err != nil {
		panic(err)
	}
}

func main() {
	codeTemplate := `
		package events

		// GENERATED CODE! DO NOT EDIT THIS FILE!
		// ADD YOUR EVENT AND RUN 'go generate' INSTEAD

		import (
			"time"
		)

		const (
			eventQueuesCapacity = {{ .InitialPriorityQueueCapacity }}
			idleDispatcherSleepTime time.Duration = 5 * time.Millisecond
			registeringListenerWhileRunningErrorMessage = "Tried to register listener while running event loop. Registering listeners is not thread safe therefore prohibited after starting event loop."
		)

		// INTERFACE DOCUMENTATION

		{{ range .EventTypes }}
			// {{ .TypeName }} event
			// Implement the interface below
			type {{ .ListenerTypeName }} interface {
				{{ .ListenerHandleMethodName }}(*{{ .TypeName }})
			}
			// and use {{ $.TypeName }}.{{ .RegisterMethodName }}({{ .ListenerTypeName }}) to register listener
			// use {{ $.TypeName }}.{{ .FireMethodName }}(*{{ .TypeName }}) to trigger event
		{{ end }}

		// END OF INTERFACE DOCUMENTATION

		// PRIVATE EVENT HANDLERS

		type {{ .EventHandlerInterfaceName }} interface {
			handle()
		}

		{{ range .EventTypes }}
			type {{ .HandlerTypeName }} struct {
				event *{{ .TypeName }}
				eventListeners []{{ .ListenerTypeName }}
			}

			func (h *{{ .HandlerTypeName }}) handle() {
				for _, listener := range h.eventListeners {
					listener.{{ .ListenerHandleMethodName }}(h.event)
				}
			}
		{{ end }}

		// EVENT DISPATCHER

		type {{ .TypeName }} struct {
			running bool

			// EVENT QUEUES

			{{ range .OrderedPriorityQueueNames }}
				{{ . }} chan {{ $.EventHandlerInterfaceName }}
			{{ end }}

			// LISTENER LISTS

			{{ range .EventTypes }}
				{{ .ListenerListName }} []{{ .ListenerTypeName }}
			{{ end }}
		}

		// EVENT DISPATCHER CONSTRUCTOR

		func New{{ .TypeName }}() *{{ .TypeName }} {
			return &{{ .TypeName }}{
				running: false,

				// EVENT QUEUES

				{{ range .OrderedPriorityQueueNames }}
					{{ . }}: make(chan {{ $.EventHandlerInterfaceName }}, eventQueuesCapacity),
				{{ end }}

				// LISTENER LISTS

				{{ range .EventTypes }}
					{{ .ListenerListName }}: []{{ .ListenerTypeName }}{},
				{{ end }}
			}
		}

		// MAIN EVENT LOOP

		func (d *{{ .TypeName }}) {{ .EventLoopMethodName }}() {
			d.running = true

			for {
				select {
					{{ range .OrderedPriorityQueueNames }}
						case handler := <-d.{{ . }}:
							handler.handle()
					{{ end }}
				default:
					time.Sleep(idleDispatcherSleepTime)
				}
			}
		}

		// PUBLIC EVENT DISPATCHER METHODS

		{{ range .EventTypes }}
			// {{ .TypeName }}

			func (d *{{ $.TypeName }}) {{ .RegisterMethodName }}(listener {{ .ListenerTypeName }}) {
				if(d.running) {
					panic(registeringListenerWhileRunningErrorMessage)
				}

				d.{{ .ListenerListName }} = append(d.{{ .ListenerListName }}, listener)
			}

			func (d *{{ $.TypeName }}) {{ .FireMethodName }}(e *{{ .TypeName }}) {
				handler := &{{ .HandlerTypeName }}{
					event: e,
					eventListeners: d.{{ .ListenerListName }},
				}

				d.{{ .EventsQueueName }} <- handler
			}
		{{ end }}
	`

	tpl, err := template.New("event_dispatcher").Parse(codeTemplate)
	checkError(err)

	var buffer bytes.Buffer
	err = tpl.Execute(&buffer, Metadata{
		TypeName: targetTypeName,
		EventLoopMethodName: eventLoopMethodName,
		InitialPriorityQueueCapacity: initialPriorityQueueCapacity,
		EventHandlerInterfaceName: "eventHandler",
		EventTypes: supportedEvents,
	})
	checkError(err)

	formatted_code, err := format.Source(buffer.Bytes())

	err = ioutil.WriteFile(targetFilePath, formatted_code, 0644)
	checkError(err)
}
